\documentclass{article}

\usepackage[affil-it]{authblk}
\usepackage{graphicx}
\usepackage{float}
\usepackage[ruled]{algorithm2e}
\usepackage{titlepic}
\usepackage{multicol}
\usepackage{chngcntr}
\usepackage{amsmath}
\usepackage{listings}

\counterwithin{figure}{section}
\graphicspath{{../resources/}}

\SetKwProg{function}{Function}{}{end}
\newcommand{\assign}[2]{$#1 \leftarrow$ #2}

\title{COMP390 Evolving a Sorting Algorithm with SNGP}
\author{Robin Lockyer\\{\small Student ID: 201148882 \\ Primary Supervisor: Dr. David Jackson \\ Secondary Supervisor: Dr. Valentina Tamma}}
\date{2018/2019}
\titlepic{\includegraphics[width=0.5\textwidth]{UOL_Logo.png}}

\begin{document}
	
	\maketitle	
	
	\newpage
	
	\begin{abstract}
		
		Genetic programming is a technique for creating programmes not by writing them by hand, but instead by creating a population of random programmes and modifying them using an evolutionary algorithm. The desired result is that after several generations a programme that performs well at a given task is generated. GP has previously been used to successfully evolve sorting algorithms.
		
		Single node genetic programming is a variation on GP invented by Dr Jackson which structures the population of programmes in a manner that allows the use of dynamic programming when computing the result of the programmes in an effort to more efficiently generate a working solution. 
		
		This project aims to compare the effectiveness of the two methods in evolving a sorting algorithm.
		
	\end{abstract}
	\newpage
	\tableofcontents
	\newpage
	\section{Introduction}
	
        This project is was done for my project supervisor Dr David Jackson. The aim of this project is to attempt to evolve a sorting algorithm using node genetic programming (SNGP) and, if successful, compare the effectiveness of evolving sorting algorithms using standard genetic programming (GP) to evolving sorts with SNGP.
        
        The purpose of GP is to automate the creation of algorithms and programmes. This is done by applying a genetic algorithm to a population of random programmes so that successive generations of programmes improve at the desired characteristics until a functional programme is created.
        The standard approach to GP requires evaluating hundreds of programmes per generation over potentially thousands of generations and as such GP can take up a large amount of processing time. Several variations of GP have been created that try to reduce the amount of processing, including Linear Genetic Programming and Parallel Distributed GP \cite{poli_field_2008}.
        
        SNGP is one such variation devised by Dr Jackson in \textit{A New, Node-Focused Model for Genetic Programming} \cite{jackson_new_2012}. This variation makes use of a form of dynamic programming to re-use results of previously evaluated programmes. It has been shown that SNGP tends to perform better than standard GP in terms of processing time, solution rate, and solution size \cite{jackson_new_2012}. SNGP has reduced efficiency when dealing with problems with side-effects because this prevents re-use of evaluations, although it still performs better than GP at some problems with side effects \cite{jackson_single_2012}. 
        
        A sorting algorithm reads and manipulates an array of integers as it executes, and so must make use of side effects. Regular genetic programming has been shown to be capable of evolving a working sorting algorithm \cite{kinnear_evolving_1993,kinnear_generality_1993}. This makes evolving a sort a good problem to evaluate SNGP on as comparisons can be made with previous research.
        
	\section{Background}
	
    \subsection{Standard Genetic Programming}\label{Section:GP}
        
        Genetic programming allows the user to automate finding solutions to problems without the need to know much about the solutions themselves. This is done by a stochastic process where successive generations of programmes are altered to create the next generation, with the goal of each generation being an improvement on the last until a desired result is found.
        
        In standard the standard form of GP, described in \textit{A Field Guide to Genetic programming} \cite{poli_field_2008}, programmes are encoded as a tree of primitive functions and terminals. Each function has a number of child nodes equal to it's arity, and each individual child represents a single operand of the parent function. Nodes with no children represent terminal functions or constants which require no input. Figure \ref{fig:ex_prog_tree} shows an example of a programme encoded as a tree.
        
        \begin{figure}
            \centering
            \includegraphics[width=0.5\textwidth]{1_gp_example_tree}
            \caption{This tree encodes the programme f( g( a, b, c ), f( h( a ), a ) ), where f, g, and h are functions and a, b, and c are terminals.}
            \label{fig:ex_prog_tree}
        \end{figure}
        
        An initial population of random programme trees is generated according to certain parameters that can vary depending on implementation. Each member of the population is executed in turn. The results of these executions are evaluated and each member of the population is given a fitness score so that better programmes have higher scores.
        
        Members of the population are then selected to produce offspring programs based on their fitness. Simply selecting the best individuals to reproduce can lead to low diversity in the resulting population, so a probabilistic is often used to prevent a single programme's offspring from dominating subsequent generations.
        Common methods for doing this include fitness proportionate selection, where the probability of selection is proportional to the fitness of the individual relative to the fitness of the whole population, and tournament selection, where a small subset of programmes are chosen with equal probability and the fittest of the subset is selected for reproduction.
        
        Genetic operators are then applied to the chosen programmes to create a new generation. The operator selected to create each member is chosen with a pre selected probability. The three most commonly used operators, which are also the three operators Koza used to successfully evolve a sort \cite{kinnear_evolving_1993}, are:
        
        \begin{itemize}
            \item \textbf{Reproduction:} 
            
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.3\textwidth]{5_reproduction}
                \caption{Example of reproduction operator}
                \label{fig:reproduction}
            \end{figure}
            
            The selected programme is copied into the new generation without modification. Reproduction tends to have a low selection probability to ensure the following generation si sufficiently different.
            
            \item \textbf{Crossover:} 
            
            \begin{figure}[h]
                \centering
                \includegraphics[height=0.2\textwidth]{6_crossover}
                \caption{Example of crossover operation. The highlighted nodes are the crossover points}
                \label{fig:crossover}
            \end{figure}
            
            A random node is selected as the crossover point in each of the two chosen programmes and the subtrees rooted at the selected nodes are swapped.
            
            
            \item \textbf{Mutation:} 
            
            \begin{figure}[h]
                \centering
                \includegraphics[width=0.4\textwidth]{7_mutation}
                \caption{Example of mutation operator. The highlighted node is replaced by the highlighted subtree.}
                \label{fig:mutation}
            \end{figure}
            
            A random node is selected in the chosen programme. A new, random subtree is generated to replace the subtree rooted at the selected node.
        \end{itemize}
        
        The process of creating new generation is continued until a certain condition is reached, usually after a certain number of generations or a programme exceeds a fitness specified by the user.
        
        Genetic programming has been previously been shown to evolve a sorting algorithm by Kenneth E Kinnear \cite{kinnear_generality_1993,kinnear_evolving_1993}. hIS work was not focused on evolving an optimal sort, but instead attempting to see if GP was capable of evolving any kind of sort at all. Kinnear considered sorting to be an interesting problem to solve using GP as there are many possible ways to implement a sorting algorithm, and the domain of the problem is infinite.
        
	\subsection{Single Node Genetic Programming}
	
        Single Node Genetic Programming is a variant of GP that uses a form of dynamic programming to speed up the evaluation of GP programmes.
        
        The population is organised a single directed acyclic graph. This allows the nodes to be organised into a topological ordering such that any given node only uses nodes later in the ordering as operands. The nodes are stored in an array in this order, with all the terminals occupying the lowest values, as shown in Figure \ref{fig:sngp_graph}.
        
        \begin{figure}[h]
            \centering
            \includegraphics[width=0.5\textwidth]{8_sngp_graph}
            \caption{This SNGP graph is stored in topological order in an array. Terminals a,b, and c occupy the lowest positions of the array.}
            \label{fig:sngp_graph}
        \end{figure}
        
        Every subtree within the graph represents a single programme. For example the graph in Figure \ref{fig:sngp_graph} contains the following programmes:
        
        \begin{multicols}{2}
            \begin{itemize}
                \item a
                \item b
                \item c
                \item g( b, c )
                \item g( a, b )
                \item h( g( b, c ), c )
                \item f( g( a, b ), g( b, c ) )
                \item f( g( b, c ), h( g( b, c ), c ) )
            \end{itemize}
        \end{multicols}
        
        This allows many different programmes to be represented in a single graph as each node is itself a programme, while in regular GP there are many nodes per programme. The structure also allows for sharing of subtrees between programmes so that if there exists a programme with a particularly high fitness, other programmes can make use of the same subtrees to improve their fitness.
        
        Evaluation of the population starts from the subtree rooted at the lowest element of the array and works upwards. The results of each evaluation are saved and can be re-used whenever the subtree needs to be executed as part of a larger programme, making the evaluation of an SNGP population very efficient.
        
        SNGP uses only one genetic operator called \textit{successor mutate}. This operator picks a random function node in the graph and changes an operand with another random node with a lower index in the population array. Instead of the whole population being re-evaluated only the the modified node and programmes that make use of that node need to be evaluated. These nodes can be determined by keeping track of the parents of each node and using this information backtrack up the graph from the modified node. When backtracking to determine which nodes to update it is important to visit nodes in array order to ensure that subtrees are updated before their results are re-used.
        
        \begin{figure}[h]
            \centering
            \includegraphics[width=0.5\textwidth]{10_successor_mutate}
            \caption{A successor mutate operation is applied to the highlighted node on the left graph, resulting in the right graph. Highlighted nodes on the left graph should be re-evaluated}
            \label{fig:successor_mut}
        \end{figure}
        
        Successor mutate allows for the modification of many programmes with a single genetic operator, and the modification itself is very efficient. Evaluation of the new population tend to be more efficient than in GP as SNGP can make use of the prior evaluation from the unchanged subtrees from the previous generation.
        
        After application of the successor mutate operator the population as a whole is given a fitness value. If the application has improved the fitness value then the change is kept, otherwise the change is reverted. There are variation of SNGP that differ in how to assign a fitness to the population:
        
        \begin{itemize}
            \item \textbf{SNGP/A:} The population fitness is the average fitness of the whole population.
            
            \item \textbf{SNGP/B:} The population fitness is the fitness of the best individual within the population.
        \end{itemize} 
        
        Like GP, this process is repeated for a certain number of generations or a programme exceeds a fitness specified by the user.
        
        SNGP has been shown to produce a working solutions after fewer generations than GP, as well as producing many more working solutions in the same number of generations \cite{jackson_new_2012}. The programmes produced tend to be smaller than those in GP, most likely due to the maximum size of any programme being capped by the size of the population, and the re-use of subtrees within a single programme.
        
        SNGP cannot make use of dynamic programming when dealing with primitives with side effects. The result of a subtree may differ depending on what is executed beforehand, so the subtree must be executed again for each other programme that makes use of it. However, even with this disadvantage SNGP/B still requires fewer evaluations to find a solution than GP in some cases, although this is dependant on the specific problem being solved \cite{jackson_single_2012}.
        
	\section{Design and Realisation}
	
	\subsection{GP Implementation}
	
        The GP implementation was based example code given by Dr Jackson and also on an implementation of the TinyGP system found in the book \textit{A Field Guide to Genetic
            Programming} \cite{poli_field_2008}. It was written in C as the example code given to me was also in C. The parameters are the same as described in Koza's work \cite{kinnear_generality_1993}.
        
        Each programme is stored as a string of primitive functions and terminals. The string is in prefix notation, and as all primitives have fixed arity no bracketing is needed. Programmes also store their fitness and their size. The information is stored as a struct, detailed in Figure \ref{struct:gp_prog}.
        
        \begin{figure}[h]
            \centering
            \begin{tabular}{|l l|}
                \hline
                \multicolumn{2}{|c|}{Prog}\\
                \hline
                Primitive[] & code \\
                double & fitness\\
                int & proglen\\
                \hline
            \end{tabular}
            \caption{Data structure to store a programme. The \textit{code} array stores a string representing the prefix notation of the programme tree, \textit{fitness} stores the programmes fitness, and \textit{proglen} the number of nodes in the programme tree.}
            
            \label{struct:gp_prog}
        \end{figure}
        
        The primitives used for this implementation are the same nine Kinnear used:
        \begin{multicols}{2}
            \begin{itemize}
                \item \textbf{INDEX:} A terminal that gives the current index of the ITERATE function.
                \item \textbf{LENGTH:} A terminal that gives the length of the current array.
                \item \textbf{ITERATE(start, end, function):}  Sets index to the value of start and increments index by one until index equals end or index equals length -1. Each iteration will execute function a single time. This primitive will return the minimum of end and LENGTH. To prevent excessive execution time, programmes are capped at 10000 total iterations.
                \item \textbf{SWAP(x,y):}  Swaps the elements of the array at positions x and y. Returns x.
                \item \textbf{SMALLEST(x,y):} Compares the values of the array at x and y. Returns the index of the smaller.
                \item \textbf{LARGEST(x,y):} Compares the values of the array at x and y. Returns the index of the larger. 
                
                \item \textbf{SUBTRACT(x,y):} Returns the value of x – y.
                \item \textbf{INCREMENT(x):} Returns the value of x+1.
                \item \textbf{DECREMENT(x):} Returns the value of x-1.
                
            \end{itemize}
        \end{multicols}
        
        The primitives are defined in an enumeration, and a table is kept to store the names and arities of the primitives. An additional \textit{DUMMY} primitive is also included to occupy the 0 value of the enumeration and make all actual primitives have arity > 0. This is useful when debugging and in certain algorithms for identifying when a primitive has not been assigned. These data structures are shown in Figure \ref{struct:arity}.
        
        \begin{figure}[h]
            \centering
            
            enum Primitive = $\left \{p1,p2,…,pn-1,pn \right\}$
            
            \smallskip
            
            \begin{tabular}{|l l|}
                \hline
                \multicolumn{2}{|c|}{TableEntry}\\
                \hline
                Primitive & primitive \\
                int & arity\\
                char[] & name\\
                \hline
            \end{tabular}
            
            \bigskip
            
            TableEntry[] arityTable = $\left\{\left \{ p1,0,"PrimitiveName"\right\},…,\left\{ pn,k,"PrimitiveName"\right\}\right\}$
            
            \caption{Data structures used to store information about primitives}
            
            \label{struct:arity}
        \end{figure}
        
        The each member of the population is initialised by using the grow method. A maximum tree depth is specified and a random primitive is selected as the root. Random primitives are selected as the children for primitives that have been previously selected. The primitives can be either functions or terminals, unless selecting a function would cause the tree to exceed the maximum depth. The initial maximum depth is chosen to be 6 to match Koza's work. The pseudocode for the algorithm is shown in algorithm \ref{alg:createTree}.
        
        \begin{algorithm}
            \SetKw{createTree}{createTree}
            
            
            \function{\createTree{$(maxDepth)$}:}{
                
                
                
                \uIf{$maxTreeDepth = 1$}{
                    
                    \KwOut{$randomTerminal()$}
                    
                }
                \Else{elseif-block}{
                    
                    \assign{root}{$randomPrimitive()$}
                    
                    \For{\assign{i}{1} to $arityTable[root].arity$}{
                        
                        \assign{root.operand[i]}{\createTree{$(maxDepth-1)$}}
                        
                    }
                    
                    \KwOut{root}
                    
                }
            }
            
            \label{alg:createTree}
            \caption{Algorithm to initialise a programme as a random tree with a given depth}
        \end{algorithm}

        Three genetic operators used are the three mentioned in section \ref{Section:GP}. Crossover is used to generate 80\% of the next generation, and 20\% is generated by reproduction. There is also a 10\% change that mutation will be applied to each member of the new population. The pseudocode for this is shown in algorithm \ref{alg:GP}.

        \begin{algorithm}[H]
            
            $initialisePopulation()$
            
            $evaluatePopulation(0)$
            
            \For{$generation \leftarrow 1$ \KwTo $NUM\_GENERATIONS$}{
                
                \For{$j \leftarrow$  \KwTo $POPULATION\_SIZE$}{
                    
                    \uIf{$randInt(1,10) <= 8$}{
                        
                        $newPopulation[j] \leftarrow crossover(selectProg(),selectProg())$
                        
                    }
                    \Else{$newPopulation[j] \leftarrow reproduce(selectProg())$ }
                    
                }
                
                \ForEach{$programme \in newPopulation$}{
                    
                    \If{$randInt(1,10) = 1$}{
                        
                        $mutate(programme)$
                        
                    }
                    
                }
                
                $population \leftarrow newPopulation$
                
                $evaluatePopulation(generation)$
                
            }
            
            \KwOut{$best(population)$}
            
            \caption{Genetic Programming Algorithm}
            
            \label{alg:GP}
        \end{algorithm}
    
    	\bigskip
    
    	The three genetic operators use the following algorithms:
    	
    	\begin{algorithm}[H]
    		
    		\KwIn{parentProg}
    		
    		\KwOut{parentProg}
    		
    		\caption{Reproduction Operator}
    		
    		\label{alg:reproduction}
    		
    	\end{algorithm}
    
    	\begin{algorithm}[H]
    		
    		\KwIn{parentProg1}
    		\KwIn{parentProg2}
    		
    		\assign{crossoverPoint1}{$randInt(1,parent1.proglen)$}
    		\assign{crossoverPoint2}{$randInt(1,parent2.proglen)$}
    		
    		\assign{childProg1}{$replaceSubtree( parentProg1, crossoverPoint1, parentProg2.prog[crossoverPoint2] )$}
    		
    		\assign{childProg2}{$replaceSubtree( parentProg2, crossoverPoint2, parentProg1.prog[crossoverPoint1] )$}
    		
    		\KwOut{childProg1}
    		\KwOut{childProg2}
    		
    		\caption{Crossover Operator}
    		
    		\label{alg:crossover}
    		
    	\end{algorithm}
    
    	\begin{algorithm}[H]
    		
    		\KwIn{parentProg}
    		
    		\assign{randomNode}{$randInt(1,parentProg.proglen)$}
    		
    		\assign{childProg}{$replaceSubtree( parentProg, randomNode, randomTree() )$}
    		
    		\KwOut{childProg}
    		
    		\caption{Mutation Operator}
    		
    		\label{alg:mutation}
    		
    	\end{algorithm}
    
    	

	\subsection{SNGP Implementation}
        
        The SNGP implementation was solely based on Dr Jackson example code. Much of it was re-used from my GP implementation, including the primitives and arity table.
        
        Each node in the SNGP population stores its current fitness, fitness from th previous generation, an array of operands, an array of predecessors, and the number of nodes in the programme tree. This is stored in the data structure shown in figure \ref{struct:sngp_node}. An arity table is also stored in the same was as in GP.
        
        \begin{figure}[H]
            \centering
            \begin{tabular}{|l l|}
                \hline
                \multicolumn{2}{|c|}{Node}\\
                \hline
                Primitive & primitive \\
                double & fitness\\
                double & oldFitness\\
                int[] & operands\\
                iny[] & predecessors\\
                int & proglen\\
                \hline
            \end{tabular}
            \caption{Data structure to store information about each node in the SNGP population}
            
            \label{struct:sngp_node}
        \end{figure}
        
        The array of predecessors is a fixed length, the same as the population array. It stores the indicies of each predecessor in a linked list, where $predecessor[0]$ contains the value of the predecessor with the smallest index, $p_1$, and then $predecessor[p_1]$ stores the value of the next largest predecessor, $p_2$, and so on until $predecessor[p_n] = 0$. This method allows for efficient traversal, insertion, and deletion, while using a fixed amount of memory.
        
        \begin{figure}[h]
        	
        	\centering
        	\includegraphics[width=0.5\textwidth]{predecessor_array}
        	\caption{A predecessor array containing the indices 2, 5, and 7}
        	\caption{fig:predecessor}
        	
        \end{figure}
    
    	This structure is used again to determine which nodes should be updated after performing a successor mutate operation.
    	
    	\begin{algorithm}[H]
    		
    		\SetKw{buildUpdateList}{buildUpdateList}
    		\SetKw{addToUpdateList}{addToUpdateList}
    		
    		\function{\buildUpdateList{$(mutatedNodeIndex)$}:}{
    			
    			$addToUpdateList(mutatedNodeIndex)$
    				
    			\assign{predecessors}{$population[mutatedNodeIndex].predecessors$}
    			
    			\assign{nextPredecessorIndex}{$predecessors[0]$}
    			
    			\While{$\lnot(nextPredecessorIndex = 0)$}{
    			
    				\assign{inList}{addToUpdateList($nextPredecessorIndex)$}
    				
    				\If{$inList$}{
    				
    					$buildUpdateList(nextPredecessorIndex)$
    			
    				}
    			
    				\assign{nextPredecessorIndex}{$predecessors[nextPredecessorIndex]$}
    		
    			}
    			
    		}
    		\function{\addToUpdateList{$(nodeIndex)$}:}{
    			
    			\assign{nextValue}{$0$}
    				
    			\While{$\lnot(updateList[nextValue] = 0)\land updateList[nextValue] < nodeIndex$ }{
    			
    				\assign{nextValue}{$updateList[nextValue]$}
    				
    			}
    		
    			\uIf{$\lnot(updateList[nextValue] = nodeIndex)$}{
    			
    				\assign{updateList[nodeIndex]}{$updateList[nextValue]$}
    				\assign{updateList[nextValue]}{$nodeIndex$}
    				
    				\KwOut{False}
    		
    			}
    			\Else{\KwOut{True}}
    	
    		}
    		
    		\caption{Create list of nodes to be updated}
    		\label{alg:updateList}
    		
    	\end{algorithm}
        \bigskip
        The pseudocode for the overall SNGP algorithm is:
        
        \begin{algorithm}[h]
        	
        	$initialisePopulation()$
        	\assign{fitness}{$evaluatePopulation()$}
        	
        	\assign{oldFitness}{$infinity$}
        	
        	\For{$generation \leftarrow 1$ \KwTo $NUM\_GENERATIONS$}{
        	
        		\assign{randomNodeIndex}{$randInt(1,POPULATION_SIZE)$}
        		
        		$successorMutate(randomNodeIndex)$
        		
        		$buildUpdatelist(randomNodeIndex)$
        		
        		\assign{oldFitness}{$fitness$}
        		
        		\assign{fitness}{$evaluatePopulation()$}
        		
        		\If{$fitness<=oldFitness$}{
        		
        			$undoSuccessorMutate()$
        			\assign{fitness}{$oldFitness$}        			
        		}
    
			}
        	
        	\KwOut{bestProgramme()}
        	
        	\caption{SNGP Algorithm}
        	\label{alg:sngp}
        \end{algorithm}
    
    	The two methods of calculating the populations overall fitness are SNGP/A and SNGP/B, which are described in the following algorithms:
    	
    	\begin{algorithm}[h]
    		
    		\KwIn{population}
    		
    		\assign{totalfitness}{$0$}
    		
    		\ForEach{$programme \in population$}{
    		
    			\assign{totalFitness}{$totalFitness + evaluate(programme)$}
    	
    		}
    	
    		\KwOut{totalFitness/size(population)}
    		
    		\caption{Calculate the SNGP/A fitness}
    		\label{SNGP/A}
    	\end{algorithm}
    
    	\begin{algorithm}[h]
    		
    		\KwIn{population}
    		
    		\assign{bestfitness}{$0$}
    		
    		\ForEach{$programme \in population$}{
    			
    			\assign{totalFitness}{$max(bestFitness,evaluate(programme))$}
    			
    		}
    		
    		\KwOut{bestFitness}
    		
    		\caption{Calculate the SNGP/A fitness}
    		\label{SNGP/B}
    	\end{algorithm}
	
	\subsection{Fitness Function}
	
        While many different fitness functions were used, they all counted the number of inversions in a test array before and after executing a programme. To efficiently count inversions I used a modified merge sort algorithms, detailed in algorithm \ref{alg:countInv}. The algorithm is $O(n\log{}n)$, and merging is done using two preallocated buffers to avoid unnecessary memory allocations while the GP algorithm is running.
        
        \begin{algorithm}[H]
            
            \SetKw{countInversions}{countInversions}
            
            \function{\countInversions{$(arr)$}:}{
                
                \uIf{$length(arr) <= 1$}{
                    
                    \assign{inversions}{$0$}
                    
                }
                
                \Else{
                    
                    \assign{sizeA}{$\left\lfloor length(arr) / 2 \right\rfloor$}
                    
                    \assign{sizeB}{length(arr) - sizeA}
                    
                    \assign{A}{[First sizeA elements of arr]}
                    
                    \assign{B}{[Last sizeB elements of arr]}
                    
                    \assign{inversions}{countInversions(A) + countInversions(B)}
                    
                    \assign{C}{Empty Array}
                    
                    \While{$length(A) > 0 and length(B) > 0$}{
                        
                        \uIf{$B[1] < A[1]$}{
                            
                            Append B[1] to C
                            
                            \assign{inversions}{inversions + length(A)}
                            
                            Remove first element of B
                            
                        }
                        \Else{
                            
                            Append A[1] to C
                            
                            Remove first element of A
                            
                        }
                    }
                    
                    \uIf{$length(A) = 0$}{
                        
                        Append remaining elements of B to C
                        
                    }
                    \ElseIf{$length(B) = 0$}{
                        Append remaining elements of A to C
                    }
                    
                    \assign{arr}{C}
                    
                }
                
                \KwOut{inversions}
                
            }
            
            \caption{Algorithm that sorts array and counts number of inversions}
            
            
            
            \label{alg:countInv}
            
        \end{algorithm}
        
        The fitness function I used as a starting point for both my GP and SNGP implementations was the same Kinnear used in \cite{kinnear_evolving_1993,kinnear_generality_1993}. The function is defined as the following:
        
        \begin{figure}[H]
            $$fitness(prog) = \frac{adjusted(prog)}{\sum_{p\in population}^{}adjusted(p)}$$
            
            $$adjusted(prog) = \frac{1}{1 + raw(prog)}$$
            
            $$raw(prog) = praw(prog) - \min_{p\in population} praw(p)$$
            
            $$praw(prog) = \left(\sum_{t = 1}^{Number Of Tests}res(t)\right) \cdot of + size(prog) \cdot sf$$
            
            $$res(t) = rdis(t) + pdis(t)$$
            
            $$pdis(t) = max(rdis(t) - idis(t), 0) \cdot 100$$
            
            \caption{Kinnear's Fitness Function}
            
            \label{kinnear_fitness}		
        
        \end{figure}
        Where $rdis(t)$ is the remaining number of inversions in a test array t after running a member of the population, $idis(t)$ is the initial number of inversions in a test array $t$, and the order factor $of$ and size factor $sf$ are constant weights used to adjust the resulting fitness.
        
        For SNGP, I also used other fitness function I created myself. The vast majority of these were not effective at all, and so will not be included. The ones that seemed to work best were some variation on the following:
        
        \begin{figure}[H]
        	$   fitness(x) =
        	\begin{cases} 
	        	1 & \mbox{if } rdis(t) = 0 \\
	        	-rdis(t) & \mbox{if } rdis(t) > idis(t) \land rdis(t) \neq 0 \\
	        	0 & \mbox{if }  rdis(t) = idis(t) \land rdis(t) \neq 0 \\
	        	1 - rdis(t)/idis(t) & \mbox{otherwise }
        	\end{cases}
        	$
        	
        	\caption{Fitness Function 1}
        	\label{ftns_func1}
        \end{figure}

    \subsection{Test Data}
        
        Each programme generated during a GP run or an SNGP run is executed on a set of test arrays. This data comes from pre-generated file containing a series of random arrays loaded into the programme at the beginning of execution. This has the advantage of allowing for reproduction of results, easier testing of the programme, and prevents random number generation from increasing the execution time.
        
        The arrays are organised into fixed size groupings. Each programme in the same GP generation is executed on the same group of arrays. This was done so that each programme was subjected to the same conditions in each generation, while still preventing over fitting to a fixed set of data. This method also allows each group to be customized to meet certain requirements (e.g. contains a sorted array, a reversed array, or a very short array), but this was found to be unnecessary.
        
        The file is a standard text file where the first two values on each line are the length and number of inversions of the array, followed by the array itself. Each value is separated by a space. A blank line indicates the end of the current group of arrays.
        
        When loaded into the programme, the test arrays are stored as the following struct:
        
        \begin{figure}[h]
            \centering
            \begin{tabular}{|l l|}
                \hline
                \multicolumn{2}{|c|}{Array}\\
                \hline
                int & size \\
                int & inversions\\
                int[] & arr\\
                \hline
            \end{tabular}
            \caption{Data structure to store each test array}
            
            \label{struct:array}
        \end{figure}
    
    	The files were generated by a python script, and the inversions counted using algorithm \ref{alg:countInv}. This allowed me to easily change the parameters of the test files and experiment with what worked.

    \section{Results}

        I was successful in replicating Kinnear's work in evolving a sorting algorithm using standard GP, and found his methods able to evolve a sort very easily with no modification. Figure \ref{g:gp_success} shows his method very easily able to evolve a sort within a couple of generations, and quickly plateaued to around 500 solutions per generation.
        
        \begin{figure}[h]
        	\centering
        	\includegraphics[width=0.5\textwidth]{g_gp_success}
        	\caption{.Graph of number of solutions generated by GP (vertical) against generation (horizontal). Population size 1000, 50 generations. Size factor = 5, order factor = 5}
        	\label{g:gp_success}
        \end{figure}
    
    	My SNGP implementation was far less successful, however. I was not able to create an implementation that could reliably generate a working solution. I do not believe this to be an error in my code as by seeding the initial population with a handmade working solution my implementation was able to identify it as a working sorting algorithm and re-use some of the structures within it to great success. I also attempted to seed the population with a partial solution containing useful structures, and the implementation was able to use it to create a working solution in approximately 6.7\% of runs, using a population of 1000, 50 generations, and my own fitness function mentioned in figure \ref{ftns_func1}.
    	
    	I found little difference in results no matter the parameters used for SNGP. Using Kinnear's fitness function always resulted in plateauing between a fitness of 0.005 and 0.01 after about 15 generations. My own fitness functions faired no better, reaching its maximum of 0.4 by 20 generations.
    	
    	All tests were over 20 runs. The custom fitness function refers to the function in figure \ref{ftns_func1}. Parameters tested include:
    	
    	\begin{itemize}
    		\item SNGP/A or SNGP/B
    		\item Population size
    		\item Number of generations
    		\item Fitness function
    		\item Size factor and order factor in Kinnear's function
    		\item Strict or non strict successor mutate. Strict successor mutate only keeps changes that result in strictly greater fitness and reverts the rest, while non strict keeps changes that have greater than or the same fitness.
    	\end{itemize}
    	
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpA_kinnear}
    		\caption{Graph of fitness against generation. SNGP/A, Population size 1000, 50 generations. Size factor = 5, order factor = 5. Kinnear's fitness function.}
    		\label{g:sngpa_kinnear}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_kinnear}
    		\caption{Graph of fitness against generation. SNGP/A, Population size 1000, 50 generations. Size factor = 5, order factor = 5. Kinnear's fitness function.}
    		\label{g:sngpb_kinnear}
    	\end{figure}
    
	    \begin{figure}[H]
	    	\centering
	    	\includegraphics[width=0.5\textwidth]{g_sngpb_kinnear_p500_o100}
	    	\caption{Graph of fitness against generation. SNGP/B, Population size 500, 100 generations. Size factor = 5, order factor = 5. Kinnear's fitness function.}
	    	\label{g:sngpb_kinnear_p500}
	    \end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_kinnear_p1500_o30}
    		\caption{Graph of fitness against generation. SNGP/B, Population size 1500, 30 generations. Size factor = 5, order factor = 5. Kinnear's fitness function.}
    		\label{g:sngpb_kinnear_p1500}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_kinnear_SF0}
    		\caption{Graph of fitness against generation. SNGP/B, Population size 1000, 50 generations. Size factor = 0, order factor = 5. Kinnear's fitness function.}
    		\label{g:sngpb_kinnear_sf0}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_kinnear_sf2}
    		\caption{Graph of fitness against generation. SNGP/B, Population size 1000, 50 generations. Size factor = 2, order factor = 5. Kinnear's fitness function.}
    		\label{g:sngpb_kinnear_sf2}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_kinnear_sf8}
    		\caption{Graph of fitness against generation. SNGP/B, Population size 1000, 50 generations. Size factor = 8, order factor = 5. Kinnear's fitness function.}
    		\label{g:sngpb_kinnear_sf8}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_kinnear_strict}
    		\caption{Graph of fitness against generation. SNGP/B strict, Population size 1000, 50 generations. Size factor = 5, order factor = 5. Kinnear's fitness function.}
    		\label{g:sngpb_kinnear_strict}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_ff}
    		\caption{Graph of fitness against generation. SNGP/B, Population size 1000, 50 generations. Custom fitness function.}
    		\label{g:sngpb_ff}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_ff_p1500_o30}
    		\caption{Graph of fitness against generation. SNGP/B, Population size 1500, 30 generations. Custom fitness function.}
    		\label{g:sngpb_ff_p1500}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_ff1_p500_o100}
    		\caption{Graph of fitness against generation. SNGP/B, Population size 500, 100 generations. Custom fitness function.}
    		\label{g:sngpb_ff_p500}
    	\end{figure}
    
    	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.5\textwidth]{g_sngpb_ff_strict}
    		\caption{Graph of fitness against generation. SNGP/B strict, Population size 500, 100 generations. Custom fitness function.}
    		\label{g:sngpb_ff_strict}
    	\end{figure}
    
    	In conclusion, I believe that SNGP is not effective at evolving a sorting algorithm.
        
    \section{Evaluation and Learning Points}
    
    	While I was not successful in evolving a sort using SNGP, I achieved my goal of  assessing the performance of SNGP in evolving a sort. There is room for further analysis of why SNGP is not effective at this task, such as by experimenting with other parameters or finding other peroblems that aren't suitable to be solved by SNGP and comparing them. 
    	
    	Throughout the course of this project I have learnt how to specify a substantial problem and how t put together a plan to complete the problem. I have improved my skills at locating relevant information and making use of it within the project, and I can use it to help evaluate and contextualise my own work.
    	
    	I now have a much wider knowledge of current research topics within the field, and a much deeper understanding of machine learning, the areas where it can be applied, and the strengths and weaknesses of the techniques used in this domain.
    	
    	This project was also another chance for me to improve my ability to produce a presentation and use it to convey information in a clear and concise manner. Similarly, I have also been able to practice my writing skills when making my specification and design documents and this report. My C programming skills have certainly improved, and I now feel much more confident in my ability to produce a working piece of software in C.
    	
    	

    \section{Professional Issues and Data Required}
    
    	This project follows the four sections of the British Computer Society Code of Conduct:
    	
    	\begin{itemize}
    		\item \textbf{Public Interest:} This section concerns third parties and the general public. This project does not contain any public components, or interact with any third parties or members of the public. Any documents or code used in the course of this project were freely available to me through the University of Liverpool and cited properly in the bibliography. As such this project does not affect  the public health, privacy, or security of others, and it does not breach the right of third parties, discriminate against anybody in any way.
    		
    		\item \textbf{Professional Competence and Integrity:} This section is about not claiming a level of competence that is not possessed. This project was specifically created by Dr Jackson for someone with the level of competence a third year computer science student should have. As such I believe that this project was well within my level of confidence when I requested to have this project assigned to me, and as I have successfully completed the project I still believe this to be the case.
    		
    		\item \textbf{Duty to Relevant Authority:} This section focuses on the responsibilities I am held to by a relevant authority. In this case the relevant authority is the University of Liverpool. I have not disclosed any confidential information, misrepresented any of my work, or caused a conflict of interest. I have carried out my responsibilities and accept professional responsibility for my work.
    		
    		\item \textbf{Duty to the Profession:} This section relates to the reputation of the computer science profession. By following the previous section I believe I have avoided any action that could bring the profession into disrepute. I have also not committed any crime or become bankrupt for the duration of this project, so I have no need to notify the BCS.
    	\end{itemize}
    
    	In regard to the data required for this project, I believe there is no need for proof of consent or ethical source of data as there was no human participation or human data used in this project.

    \section{Bibliography}

	    \bibliographystyle{acm}
	    \bibliography{library}

    \section{Appendices}
    	
    	Code listing for GP\_Sort.c
    	
	    \begin{lstlisting}
	    
	    #include <stdio.h>
	    #include <stdlib.h>
	    #include <time.h>
	    
	    #define RANDOM_SEED time(NULL)//1894
	    
	    #define NUM_TERMINALS 2
	    #define NUM_FUNCTIONS 7
	    #define NUM_PRIMITIVES NUM_TERMINALS+NUM_FUNCTIONS
	    #define MAX_ARITY 3
	    
	    #define POPULATION_SIZE 1000 //1000 in final
	    #define MAX_PROG_SIZE 3000
	    #define INITIAL_MAX_DEPTH 6
	    #define NUM_GENERATIONS 50 //50 in final
	    #define NUM_TESTS 15
	    #define MAX_RUNS 20 //20 in final
	    #define NUM_TEST_SETS 3000
	    
	    #define SF 5
	    #define OF 5
	    
	    #define MAX_MUTATE_DEPTH_INCREASE 1.15
	    
	    #define OUT_FILE "results\\gp_success_trace_2.csv"
	    FILE* successTrace = NULL;
	    
	    int numWorkingProgs = 0;
	    int workingProgramme = -1;
	    
	    typedef enum {
	    DUMMY,
	    INDEX,
	    LENGTH,
	    ITERATE, 
	    SWAP,
	    SMALLEST,
	    LARGEST,
	    SUB,
	    INC,
	    DEC
	    } Primitive;
	    
	    typedef struct {
	    Primitive primitive;
	    int arity;
	    char* name;
	    } TableEntry;
	    
	    TableEntry primitiveTable[NUM_PRIMITIVES+1] = {
	    {DUMMY,   -1, "DUMMY"},
	    {INDEX,    0, "INDEX"},
	    {LENGTH,   0, "LENGTH"},
	    {ITERATE,  3, "ITERATE"},
	    {SWAP,     2, "SWAP"},
	    {SMALLEST, 2, "SMALLEST"},
	    {LARGEST,  2, "LARGEST"},
	    {SUB,      2, "SUB"},
	    {INC,      1, "INC"},
	    {DEC,      1, "DEC"}
	    };
	    
	    typedef struct {
	    char code[MAX_PROG_SIZE+1];//Includes null terminator
	    double fitness;
	    int progLen;
	    } Prog;
	    
	    char* progNode = NULL;
	    
	    Prog popBuffer1[POPULATION_SIZE];
	    Prog popBuffer2[POPULATION_SIZE];
	    
	    Prog* population = &popBuffer1[0];
	    Prog* newPopulation = &popBuffer2[0];
	    
	    typedef struct{
	    int size;
	    int inversions;
	    int arr[];
	    } Array;
	    
	    #define arrayMem(x) (sizeof(Array) + sizeof(int) * (x))
	    
	    Array* tests[NUM_GENERATIONS][NUM_TESTS];
	    int maxTestSize;
	    
	    Array* results = NULL;
	    int* mergeBuffer1 = NULL;
	    int* mergeBuffer2 = NULL;
	    
	    int index = 0;
	    int progIterations = 0;
	    #define MAX_PROG_ITERATIONS 10000
	    
	    //Returns random integer in interval [min,max] inclusive
	    int randRange(int min, int max){
	    
	    return min + rand()/(RAND_MAX/(max-min+1)+1);
	    
	    }
	    
	    int initialiseTestData(char* path){
	    
	    FILE* file = fopen(path,"r");
	    
	    if(!file) return 1;
	    int setNum = 0;
	    int testNum = 0;
	    maxTestSize = 0;
	    
	    //Iterate through test data file until we have a test set for each generation or EOF has been reached
	    while(setNum < NUM_GENERATIONS){
	    
	    char firstC = getc(file);
	    
	    
	    
	    //If this line is blank, then we have reached the end of this test set
	    if(firstC == '\n'){
	    ++setNum;
	    testNum = 0;
	    continue;
	    
	    //if we have exeeded the number of tests per set, skip the remainder of the set
	    }else if(testNum >= NUM_TESTS){
	    ++setNum;
	    testNum = 0;
	    
	    do{
	    fscanf(file,"%*[^\n]",NULL);
	    getc(file);
	    firstC = getc(file);
	    }while(firstC != '\n');
	    continue;
	    }
	    //If end of file has been reached, exit loop
	    else if(firstC == EOF){
	    
	    break;
	    
	    }
	    
	    ungetc(firstC,file);
	    
	    int arrSize = 0;
	    int inversions = 0;
	    
	    fscanf(file, "%d %d", &arrSize, &inversions);
	    
	    tests[setNum][testNum] = malloc( arrayMem(arrSize) );
	    
	    if(arrSize > maxTestSize) maxTestSize = arrSize;
	    
	    Array* test = tests[setNum][testNum];
	    test->size = arrSize;
	    test->inversions = inversions;
	    
	    for(int i = 0; i < arrSize; i++){
	    
	    int n;
	    
	    fscanf(file, "%d", &n);
	    
	    test->arr[i] = n;
	    }        
	    getc(file);
	    ++testNum;
	    
	    }
	    fclose(file);
	    return 0;
	    }
	    
	    //progNode must be set to Prog.code before this is called
	    //progIterations must be set to 0 before this is called
	    int execute(){
	    
	    switch(*progNode++){
	    
	    case INDEX:{
	    
	    return index;
	    
	    }break;
	    
	    case LENGTH:{
	    
	    return results->size;
	    
	    }break;
	    
	    case ITERATE:{
	    
	    int len = results->size;
	    int start = execute();
	    int end = execute();
	    char* function = progNode;
	    
	    int oldIndex = index;
	    
	    for(index = start; index <= end && index < len && progIterations < MAX_PROG_ITERATIONS; ++index, ++progIterations){
	    
	    progNode = function;
	    
	    execute();
	    }
	    
	    index = oldIndex;
	    
	    return (end < len) ? end : len ;
	    
	    }break;
	    
	    case SWAP:{
	    
	    int x = execute();
	    int y = execute();
	    
	    //If x or y is not a valid index, return 0
	    if(x<0 || y<0 || x>=results->size || y>=results->size) return 0;
	    
	    int t = results->arr[x];
	    results->arr[x] = results->arr[y];
	    results->arr[y] = t;
	    
	    return x;
	    
	    }break;
	    
	    case SMALLEST:{
	    
	    int x = execute();
	    int y = execute();
	    
	    if(results->arr[x] < results->arr[y]){
	    return x;
	    }
	    else{
	    
	    return y;
	    
	    }
	    
	    }break;
	    
	    case LARGEST:{
	    
	    int x = execute();
	    int y = execute();
	    
	    if(results->arr[x] > results->arr[y]){
	    return x;
	    }
	    else{
	    
	    return y;
	    
	    }
	    
	    }break;
	    
	    case SUB:{
	    
	    int x = execute();
	    int y = execute();
	    
	    return x-y;
	    
	    }break;
	    
	    case INC:{
	    
	    int x = execute();
	    
	    return x+1;
	    
	    }break;
	    
	    case DEC:{
	    
	    int x = execute();
	    
	    return x-1;
	    
	    }break;
	    
	    default:
	    printf("\nINVALID PRIMITIVE (%d)\n", *(progNode-1));
	    return -1;
	    }
	    
	    }
	    
	    int countInversionsRec(int* arr, int* working, int size, int offset){
	    
	    if(size <= 1){
	    
	    return 0;
	    
	    }
	    
	    int sizeA = size / 2;
	    int sizeB = size - sizeA;
	    
	    int* A = working + offset;
	    int* B = &working[sizeA] + offset;
	    
	    int inversions = countInversionsRec(working,arr,sizeA,offset) + countInversionsRec(working,arr,sizeB,sizeA+offset);
	    
	    int aCounter = 0;
	    int bCounter = 0;
	    int cCounter = offset;
	    
	    
	    while( aCounter < sizeA && bCounter < sizeB ){
	    
	    if( A[aCounter] <= B[bCounter] ){
	    
	    arr[cCounter] = A[aCounter];
	    aCounter++;
	    
	    }else{
	    
	    arr[cCounter] = B[bCounter];
	    inversions += (sizeA - aCounter);
	    bCounter++;
	    
	    }
	    
	    cCounter++;
	    
	    }
	    
	    if(aCounter < sizeA){
	    
	    memcpy( &arr[cCounter], &A[aCounter], (sizeA - aCounter) * sizeof(int));
	    
	    } else if(bCounter < sizeB){
	    
	    memcpy( &arr[cCounter], &B[bCounter], (sizeB - bCounter) * sizeof(int));
	    
	    }    
	    
	    return inversions;
	    
	    }
	    
	    int countInversions(Array* arr){
	    
	    if(mergeBuffer1 == NULL || mergeBuffer2 == NULL) return -1;
	    
	    memcpy(mergeBuffer1,arr->arr,arr->size*sizeof(int));
	    memcpy(mergeBuffer2,arr->arr,arr->size*sizeof(int));
	    
	    arr->inversions = countInversionsRec(mergeBuffer1, mergeBuffer2, arr->size, 0);
	    
	    return arr->inversions;
	    
	    }
	    
	    //returns the result of each test by calculating the remaining disorder rdis after
	    //the test and adding a penalty disorder pDis.
	    int res(int popIndex, int testSet, int testNum){
	    
	    Array* test = tests[testSet][testNum];
	    
	    //If inversions not counted, count inversions
	    if(test->inversions == -1){
	    
	    memcpy(results, test->arr, test->size);
	    countInversions(test);
	    
	    }
	    
	    index = 0;
	    
	    memcpy(results, test, arrayMem(test->size));
	    
	    progIterations = 0;
	    progNode = population[popIndex].code;
	    execute(popIndex);
	    
	    int iDis = test->inversions;
	    int rDis = countInversions(results);
	    int pDis = (rDis > iDis) ? (rDis - iDis)*100 : 0;
	    
	    return rDis + pDis; 
	    
	    }
	    
	    //Calculates the provisional raw fitness of a programme
	    int praw(int testSet, int popIndex){
	    
	    int resSum = 0;
	    
	    for(int testNum = 0; testNum < NUM_TESTS; testNum++){
	    resSum += res(popIndex,testSet,testNum);
	    }
	    
	    if(resSum == 0){
	    numWorkingProgs += 1;
	    workingProgramme = popIndex;
	    }
	    
	    return (resSum * OF) + (population[popIndex].progLen * SF);
	    
	    }
	    
	    //Calculates the fitness for each member of the population
	    void evaluatePopulation(int testSet){
	    
	    numWorkingProgs = 0;
	    
	    int prawTable[POPULATION_SIZE];
	    int raw[POPULATION_SIZE];
	    float adj[POPULATION_SIZE];
	    float adjSum = 0;
	    
	    prawTable[0] = praw(testSet, 0);
	    
	    int minpraw = prawTable[0];
	    
	    
	    //Calculate the provisional raw fitness and minimum raw fitness 
	    for(int popIndex = 1; popIndex < POPULATION_SIZE; ++popIndex){
	    
	    prawTable[popIndex] = praw(testSet, popIndex);
	    
	    if(prawTable[popIndex] < minpraw) minpraw = prawTable[popIndex];
	    
	    }
	    
	    //Calculate the adjusted fitness for each member of the population
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; ++popIndex){
	    
	    int raw = prawTable[popIndex] - minpraw;
	    
	    adj[popIndex] = 1.0/(1.0+raw);
	    
	    adjSum += adj[popIndex];
	    
	    }
	    
	    //Set the fitness for each member of the population as the normalised adjusted
	    //fitness
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; ++popIndex){
	    
	    population[popIndex].fitness = adj[popIndex]/adjSum;
	    
	    }
	    
	    fprintf(successTrace,"%d,",numWorkingProgs);
	    
	    }
	    
	    char* createTree(char* tree, int depth, int maxNodes, int full){  
	    char* treeEnd = tree;
	    
	    if (depth == 1 || maxNodes == 1){
	    *treeEnd = randRange(1,NUM_TERMINALS);
	    treeEnd++;
	    }
	    
	    else{
	    
	    char primitive;
	    int arity;
	    do{
	    
	    primitive = full ? randRange(NUM_TERMINALS+1, NUM_PRIMITIVES): randRange(1,NUM_PRIMITIVES);
	    arity = primitiveTable[primitive].arity;
	    
	    }while(arity > maxNodes-1);
	    
	    
	    *tree = primitive;
	    
	    treeEnd++;
	    
	    
	    for(int argument = 0; argument < arity; ++argument){
	    
	    treeEnd = createTree(treeEnd, depth-1, maxNodes - (treeEnd - tree) - arity + 1 + argument, full);
	    
	    }
	    }
	    return(treeEnd);
	    }
	    
	    int fitnessProportionalSelection(){
	    
	    float randNum = (float)rand()/ (float)RAND_MAX;
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; ++popIndex ){
	    
	    if(population[popIndex%POPULATION_SIZE].fitness >= randNum) return popIndex;
	    else randNum -= population[popIndex].fitness;
	    }
	    
	    //If this line of code is reached it is due to errors in floating point precision
	    return POPULATION_SIZE-1;
	    
	    }
	    
	    int subtreeLength(char* start){
	    
	    int remaining = primitiveTable[*start].arity;
	    int length = 1;
	    
	    while(remaining > 0){
	    
	    remaining--;
	    start++;
	    remaining += primitiveTable[*start].arity;
	    length++;
	    
	    }
	    
	    return length;
	    
	    }
	    
	    int subTreeDepth(char* start){
	    
	    int maxDepth = 0;
	    
	    int arity = primitiveTable[*start].arity;
	    
	    start++;
	    
	    for(int i = 0; i<arity; i++){
	    
	    int depth = subTreeDepth(start);
	    
	    if(depth > maxDepth) maxDepth = depth;
	    
	    start += subtreeLength(start);
	    
	    }
	    
	    return maxDepth+1;
	    
	    }
	    
	    //Creates a new programme at newProg by copying baseProg and replaceing the subtree rooted at oldSubtree
	    //with a copy of newSubtree
	    void replaceSubtree(char* baseProg, int baseLen, int oldSubtree, char* newSubtree, char* newProg){
	    
	    memcpy(newProg, baseProg, oldSubtree);
	    int subtreelen = subtreeLength(baseProg + oldSubtree);
	    int newSubtreeLen = subtreeLength(newSubtree);
	    memcpy(newProg + oldSubtree, newSubtree, newSubtreeLen);
	    memcpy(newProg + oldSubtree + newSubtreeLen, baseProg + oldSubtree + subtreelen, baseLen - subtreelen - oldSubtree);
	    newProg[baseLen-subtreelen+newSubtreeLen] = '\0';
	    
	    }
	    
	    void reproduction(int popIndex){
	    
	    newPopulation[popIndex] = population[fitnessProportionalSelection()];
	    
	    }
	    
	    void mutate(Prog* baseProg, int popIndex){
	    
	    //int selectedProg = fitnessProportionalSelection();
	    
	    int baseDepth = subTreeDepth(baseProg->code);
	    int maxDepth = baseDepth * MAX_MUTATE_DEPTH_INCREASE;
	    
	    int mutatedNode = randRange(0,baseProg->progLen - 1);
	    
	    int subTreeDep = subTreeDepth(&baseProg->code[mutatedNode]);
	    int subTreeLen = subtreeLength(&baseProg->code[mutatedNode]);
	    
	    char newTree[MAX_PROG_SIZE];
	    createTree(newTree, maxDepth - baseDepth + subTreeDep, MAX_PROG_SIZE - baseProg->progLen + subTreeLen, 0);
	    
	    replaceSubtree(baseProg->code, baseProg->progLen, mutatedNode, newTree, newPopulation[popIndex].code);
	    
	    newPopulation[popIndex].progLen = strlen(newPopulation[popIndex].code);
	    
	    } 
	    
	    void crossover(int popIndex1, int popIndex2){
	    
	    int parIndex1 = fitnessProportionalSelection();
	    int parIndex2 = fitnessProportionalSelection();
	    while(parIndex1 == parIndex2)parIndex2 = fitnessProportionalSelection();
	    
	    Prog* parent1 = &population[parIndex1];
	    Prog* parent2 = &population[parIndex2];
	    
	    int crossoverPoint1 = randRange(0,parent1->progLen-1);
	    int crossoverPoint2 = randRange(0,parent2->progLen-1);
	    
	    replaceSubtree(parent1->code, parent1->progLen, crossoverPoint1, parent2->code + crossoverPoint2, newPopulation[popIndex1].code);
	    newPopulation[popIndex1].progLen = strlen(newPopulation[popIndex1].code);
	    
	    if(popIndex2 < POPULATION_SIZE){
	    
	    replaceSubtree(parent2->code, parent2->progLen, crossoverPoint2, parent1->code + crossoverPoint1, newPopulation[popIndex2].code);
	    newPopulation[popIndex2].progLen = strlen(newPopulation[popIndex2].code);
	    }
	    
	    }
	    
	    void initialisePopulation(){
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; ++popIndex){
	    
	    Prog* prog = &population[popIndex];
	    
	    char* code = prog->code;
	    
	    createTree(code, 6, MAX_PROG_SIZE,0);
	    
	    prog->progLen = strlen(code);
	    
	    }
	    
	    
	    }
	    
	    int init(char* path){
	    if(path == NULL) return 1;
	    if(initialiseTestData(path)) return 1;
	    srand(RANDOM_SEED);
	    results = malloc( arrayMem(maxTestSize) );
	    mergeBuffer1 = malloc( sizeof(int) * maxTestSize );
	    mergeBuffer2 = malloc( sizeof(int) * maxTestSize );
	    return 0;
	    
	    }
	    
	    #include "GP_Sort_Debug.c"
	    int main(int argc, char* argv[]){
	    
	    printf("Start\n\n");
	    printf(argv[1]);
	    printf("\n\n");
	    
	    printPrimitiveTable();
	    
	    if(init(argv[1])){
	    printf("File Not Found");
	    return 1;
	    }else{
	    
	    printf("\nTest file loaded\n\n");
	    
	    }
	    
	    successTrace = fopen(OUT_FILE,"w");
	    
	    for(int run = 0; run<MAX_RUNS; ++run){
	    
	    //if(numWorkingProgs>0) break;        
	    
	    printf("\n\nRun %d\n\n",run);
	    
	    initialisePopulation();
	    
	    //evaluate the initial population (generation 0)
	    evaluatePopulation(0);
	    
	    for(int generation = 1; generation < NUM_GENERATIONS; ++generation){
	    
	    //if(numWorkingProgs>0) break;
	    
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; popIndex++){
	    
	    if(randRange(0,9) <= 8){
	    crossover(popIndex,(popIndex+1)%POPULATION_SIZE);
	    ++popIndex;
	    }
	    else reproduction(popIndex);
	    
	    }
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; popIndex++)
	    if(randRange(0,9) == 0){
	    Prog p = newPopulation[popIndex];
	    mutate(&p,popIndex);
	    }
	    
	    Prog* temp = newPopulation;
	    newPopulation = population;
	    population = temp;
	    
	    evaluatePopulation(generation);
	    
	    if(generation%100 == 0){
	    
	    printf("\n%d", generation);
	    
	    
	    }
	    
	    
	    
	    }
	    
	    fprintf(successTrace,"\n");
	    }
	    
	    //printPopulation();
	    
	    if(numWorkingProgs>0){
	    printf("\n\nSuccess!\n\n");
	    printNode(workingProgramme);
	    }
	    
	    fclose(successTrace);
	    
	    return 0;
	    
	    }
	    
	    \end{lstlisting}
	    
	    Code listing for GP\_Sort\_Debug.c
	    
	    \begin{lstlisting}
	    #ifndef GP_SORT_DEBUG_C
	    #define GP_SORT_DEBUG_C
	    
	    #include<stdio.h>
	    
	    void printIntArray(int* a, int n){
	    
	    for(int i = 0; i<n; i++){
	    
	    printf("%d ", a[i]);
	    
	    }
	    
	    }
	    
	    void printPrimitiveTable(){
	    
	    for(int i = 0; i < NUM_PRIMITIVES; i++){
	    
	    TableEntry entry = primitiveTable[i];
	    printf("i: %d, e: %d, a: %d n: %s\n", i, entry.primitive, entry.arity, entry.name);
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    void printTestData(){
	    
	    for(int i = 0; i < NUM_GENERATIONS; i++){
	    
	    printf("Set %d\n\n", i);
	    
	    for(int j = 0; j < NUM_TESTS; j++){
	    
	    Array* test = tests[i][j];
	    
	    printf("Test: %d-%d Size: %d Inversions: %d\n", i, j, test->size, test->inversions);
	    
	    for(int k = 0; k < test->size; k++){
	    
	    printf("%d " , test->arr[k]);
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    void printNode(int popIndex){
	    
	    Prog prog = population[popIndex];
	    printf(
	    "Index: %d ProgLen: %d Fitness: %f \nProg: ", 
	    popIndex,
	    prog.progLen,
	    prog.fitness
	    );
	    
	    for(int i = 0; i < prog.progLen; ++i){
	    
	    
	    printf("%s ",primitiveTable[prog.code[i]].name);
	    
	    }
	    
	    }
	    
	    void printPopulation(){
	    
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; popIndex++){
	    printNode(popIndex);
	    
	    printf("\n\n");
	    }
	    
	    printf("\n");
	    
	    }
	    
	    void setExampleProgramme(Prog* prog){
	    
	    Primitive code[18] = {ITERATE,SUB,LENGTH,LENGTH,DEC, LENGTH ,ITERATE,SUB,LENGTH,LENGTH,	DEC, LENGTH ,SWAP,SMALLEST,INC,INDEX,INDEX,INDEX};
	    
	    for(int i = 0; i<18; i++){
	    
	    prog->code[i] = code[i];
	    
	    }
	    
	    prog->progLen = 18;
	    
	    }
	    
	    void testExecution(){
	    
	    setExampleProgramme(&population[0]);
	    
	    res(0,0,0);
	    
	    printIntArray(results->arr, results->size);
	    
	    }
	    
	    #endif
	    \end{lstlisting}
	    
	    Code listing for SNGPSort.c
	    
	    \begin{lstlisting}
	    #include <stdio.h>
	    #include <stdlib.h>
	    #include <limits.h>
	    #include <time.h>
	    
	    
	    #define RANDOM_SEED time(NULL)//2928
	    
	    #define NUM_TERMINALS 2
	    #define NUM_FUNCTIONS 7
	    #define NUM_PRIMITIVES NUM_TERMINALS+NUM_FUNCTIONS
	    #define MAX_ARITY 3
	    
	    //Macro to define which version of SNGP is used
	    #define evaluatePopulation(updateList,testSet) evaluatePopulationSNGP_A((updateList),(testSet))
	    
	    //The maximum number of times we apply the successor mutate operation
	    #define MAX_OPS 50
	    #define NUM_GENERATIONS MAX_OPS+1
	    #define POPULATION_SIZE 1000
	    #define NUM_TESTS 15
	    #define MAX_RUNS 20
	    #define NUM_TEST_SETS 30000
	    #define BETTER_THAN >=
	    
	    #define OUTPUT_INTERVAL 5
	    
	    #define OUT_FILE "results\\sngpA_fitness_trace_ff1.csv"
	    FILE* fitnessTrace = NULL;
	    
	    #define SF 5
	    #define OF 5
	    
	    typedef struct{
	    int size;
	    int inversions;
	    int arr[];
	    } Array;
	    
	    #define arrayMem(x) (sizeof(Array) + sizeof(int) * (x))
	    
	    Array* tests[NUM_GENERATIONS][NUM_TESTS];
	    int maxTestSize;
	    
	    Array* results = NULL;
	    int* mergeBuffer1 = NULL;
	    int* mergeBuffer2 = NULL;
	    int updateList[POPULATION_SIZE];
	    
	    int index = 0;
	    int progIterations = 0;
	    #define MAX_PROG_ITERATIONS 2000
	    
	    int success = 0;
	    int workingProgramme = -1;
	    
	    //For SNGP/A
	    float totalNodeFitness = 0;
	    
	    
	    typedef enum {
	    INDEX,
	    LENGTH,
	    ITERATE, 
	    SWAP,
	    SMALLEST,
	    LARGEST,
	    SUB,
	    INC,
	    DEC
	    } Primitive;
	    
	    typedef struct {
	    Primitive primitive;
	    int arity;
	    char* name;
	    } TableEntry;
	    
	    TableEntry primitiveTable[NUM_PRIMITIVES] = {
	    {INDEX,    0, "INDEX"},
	    {LENGTH,   0, "LENGTH"},
	    {ITERATE,  3, "ITERATE"},
	    {SWAP,     2, "SWAP"},
	    {SMALLEST, 2, "SMALLEST"},
	    {LARGEST,  2, "LARGEST"},
	    {SUB,      2, "SUB"},
	    {INC,      1, "INC"},
	    {DEC,      1, "DEC"}
	    };
	    
	    typedef struct {
	    Primitive primitive;
	    double fitness;
	    double oldFitness;
	    int operands[MAX_ARITY];
	    int predecessors[POPULATION_SIZE];
	    int progLen;
	    } Node;
	    
	    Node population[POPULATION_SIZE];
	    
	    
	    
	    void addPredecessor(int popIndex, int newPredIndex){
	    
	    //If the node is a terminal, we don't need to maintain its predecessor array
	    if(popIndex < NUM_TERMINALS) return;
	    
	    Node* node = &population[popIndex];
	    
	    int* predArray = node->predecessors;
	    
	    int nextValue = 0;
	    
	    while(predArray[nextValue] != 0 && predArray[nextValue] < newPredIndex){
	    
	    nextValue = predArray[nextValue];
	    
	    }
	    
	    if(predArray[nextValue] != newPredIndex){
	    
	    predArray[newPredIndex] = predArray[nextValue];
	    
	    predArray[nextValue] = newPredIndex;
	    
	    }
	    
	    
	    
	    }
	    
	    int removePredecessor(int popIndex, int newPredIndex){
	    
	    //If the node is a terminal, we don't need to maintain its predecessor array
	    if(popIndex < NUM_TERMINALS) return 0;
	    
	    Node* node = &population[popIndex];
	    
	    int* predArray = node->predecessors;
	    
	    int nextValue = 0;
	    
	    while(predArray[nextValue] != 0 && predArray[nextValue] != newPredIndex){
	    
	    nextValue = predArray[nextValue];
	    
	    }
	    
	    //if predIndex not found in predArray, return error
	    if(predArray[nextValue] == 0) return 1;
	    
	    predArray[nextValue] = predArray[newPredIndex];
	    
	    predArray[newPredIndex] = 0;
	    
	    return 0;
	    }
	    
	    //Returns random number in interval [min,max] inclusive
	    int randRange(int min, int max){
	    
	    return min + rand()/(RAND_MAX/(max-min+1)+1);
	    
	    }
	    
	    void initialisePopulation(){
	    
	    for(int terminalIndex = 0; terminalIndex < NUM_TERMINALS; terminalIndex++){
	    
	    Node* node = &population[terminalIndex];
	    
	    node->primitive = terminalIndex;
	    
	    node->fitness = -1;
	    node->oldFitness = -1;
	    node->progLen = 1;
	    
	    }
	    
	    for(int functionIndex = NUM_TERMINALS; functionIndex < POPULATION_SIZE; functionIndex++){
	    
	    Node* node = &population[functionIndex];
	    
	    Primitive primitive = randRange(NUM_TERMINALS,NUM_PRIMITIVES-1);
	    
	    node->primitive = primitive;
	    node->fitness = -1;
	    node->oldFitness = -1;
	    node->progLen = 1;
	    node->predecessors[0] = 0;
	    
	    for(int operandIndex = 0; operandIndex < MAX_ARITY; operandIndex++){
	    
	    if( operandIndex < primitiveTable[primitive].arity ){
	    
	    int randomOperand = randRange(0,functionIndex-1);
	    
	    node->operands[operandIndex] = randomOperand;
	    node->progLen += population[randomOperand].progLen;
	    
	    addPredecessor(randomOperand, functionIndex);
	    
	    } else{
	    
	    node->operands[operandIndex] = -1;
	    
	    }
	    
	    }
	    
	    }
	    
	    }
	    
	    int initialiseTestData(char* path){
	    
	    FILE* file = fopen(path,"r");
	    
	    if(!file) return 1;
	    int setNum = 0;
	    int testNum = 0;
	    maxTestSize = 0;
	    
	    //Iterate through test data file until we have a test set for each generation or EOF has been reached
	    while(setNum < NUM_GENERATIONS){
	    
	    char firstC = getc(file);
	    
	    
	    
	    //If this line is blank, then we have reached the end of this test set
	    if(firstC == '\n'){
	    ++setNum;
	    testNum = 0;
	    continue;
	    
	    //if we have exeeded the number of tests per set, skip the remainder of the set
	    }else if(testNum >= NUM_TESTS){
	    ++setNum;
	    testNum = 0;
	    
	    do{
	    fscanf(file,"%*[^\n]",NULL);
	    getc(file);
	    firstC = getc(file);
	    }while(firstC != '\n');
	    continue;
	    }
	    //If end of file has been reached, exit loop
	    else if(firstC == EOF){
	    
	    break;
	    
	    }
	    
	    ungetc(firstC,file);
	    
	    int arrSize = 0;
	    int inversions = 0;
	    
	    fscanf(file, "%d %d", &arrSize, &inversions);
	    
	    tests[setNum][testNum] = malloc( arrayMem(arrSize) );
	    
	    if(arrSize > maxTestSize) maxTestSize = arrSize;
	    
	    Array* test = tests[setNum][testNum];
	    test->size = arrSize;
	    test->inversions = inversions;
	    
	    for(int i = 0; i < arrSize; i++){
	    
	    int n;
	    
	    fscanf(file, "%d", &n);
	    
	    test->arr[i] = n;
	    }        
	    getc(file);
	    ++testNum;
	    
	    }
	    fclose(file);
	    return 0;
	    }
	    
	    int execute(int popIndex){
	    
	    Node* node = &population[popIndex];
	    
	    switch(node->primitive){
	    
	    case INDEX:{
	    
	    return index;
	    
	    }break;
	    
	    case LENGTH:{
	    
	    return results->size;
	    
	    }break;
	    
	    case ITERATE:{
	    
	    int len = results->size;
	    int start = execute(node->operands[0]);
	    int end = execute(node->operands[1]);
	    int functionIndex = node->operands[2];
	    
	    int oldIndex = index;
	    
	    for(index = start; index <= end && index < len && progIterations < 2*results->size*results->size; ++index, ++progIterations){
	    
	    execute(functionIndex);
	    }
	    
	    index = oldIndex;
	    
	    return (end < len) ? end : len ;
	    
	    }break;
	    
	    case SWAP:{
	    
	    int x = execute(node->operands[0]);
	    int y = execute(node->operands[1]);
	    
	    //If x or y is not a valid index, return 0
	    if(x<0 || y<0 || x>=results->size || y>=results->size) return 0;
	    
	    int t = results->arr[x];
	    results->arr[x] = results->arr[y];
	    results->arr[y] = t;
	    
	    return x;
	    
	    }break;
	    
	    case SMALLEST:{
	    
	    int x = execute(node->operands[0]);
	    int y = execute(node->operands[1]);
	    
	    if(results->arr[x] < results->arr[y]){
	    return x;
	    }
	    else{
	    
	    return y;
	    
	    }
	    
	    }break;
	    
	    case LARGEST:{
	    
	    int x = execute(node->operands[0]);
	    int y = execute(node->operands[1]);
	    
	    if(results->arr[x] > results->arr[y]){
	    return x;
	    }
	    else{
	    
	    return y;
	    
	    }
	    
	    }break;
	    
	    case SUB:{
	    
	    int x = execute(node->operands[0]);
	    int y = execute(node->operands[1]);
	    
	    return x-y;
	    
	    }break;
	    
	    case INC:{
	    
	    int x = execute(node->operands[0]);
	    
	    return x+1;
	    
	    }break;
	    
	    case DEC:{
	    
	    int x = execute(node->operands[0]);
	    
	    return x-1;
	    
	    }break;
	    
	    default:
	    printf("\nINVALID PRIMITIVE (%d)\n", node->primitive);
	    return -1;
	    }
	    
	    }
	    
	    int countInversionsRec(int* arr, int* working, int size, int offset){
	    
	    if(size <= 1){
	    
	    return 0;
	    
	    }
	    
	    int sizeA = size / 2;
	    int sizeB = size - sizeA;
	    
	    int* A = working + offset;
	    int* B = &working[sizeA] + offset;
	    
	    int inversions = countInversionsRec(working,arr,sizeA,offset) + countInversionsRec(working,arr,sizeB,sizeA+offset);
	    
	    int aCounter = 0;
	    int bCounter = 0;
	    int cCounter = offset;
	    
	    
	    while( aCounter < sizeA && bCounter < sizeB ){
	    
	    if( A[aCounter] <= B[bCounter] ){
	    
	    arr[cCounter] = A[aCounter];
	    aCounter++;
	    
	    }else{
	    
	    arr[cCounter] = B[bCounter];
	    inversions += (sizeA - aCounter);
	    bCounter++;
	    
	    }
	    
	    cCounter++;
	    
	    }
	    
	    if(aCounter < sizeA){
	    
	    memcpy( &arr[cCounter], &A[aCounter], (sizeA - aCounter) * sizeof(int));
	    
	    } else if(bCounter < sizeB){
	    
	    memcpy( &arr[cCounter], &B[bCounter], (sizeB - bCounter) * sizeof(int));
	    
	    }    
	    
	    return inversions;
	    
	    }
	    
	    int countInversions(Array* arr){
	    
	    if(mergeBuffer1 == NULL || mergeBuffer2 == NULL) return -1;
	    
	    memcpy(mergeBuffer1,arr->arr,arr->size*sizeof(int));
	    memcpy(mergeBuffer2,arr->arr,arr->size*sizeof(int));
	    
	    arr->inversions = countInversionsRec(mergeBuffer1, mergeBuffer2, arr->size, 0);
	    
	    return arr->inversions;
	    
	    }
	    
	    float testNode(int popIndex, int testSet, int testNum){
	    
	    Array* test = tests[testSet][testNum];
	    
	    //If inversions not counted, count inversions
	    if(test->inversions == -1){
	    
	    memcpy(results, test->arr, test->size);
	    countInversions(test);
	    
	    }
	    
	    index = 0;
	    
	    memcpy(results, test, arrayMem(test->size));
	    
	    progIterations = 0;
	    execute(popIndex);
	    
	    
	    int inversions = countInversions(results);
	    
	    float fitness;// = test->inversions - inversions;
	    
	    if(inversions == test->inversions && inversions!=0) fitness = 0;
	    else if(test->inversions!=0) fitness = 1 - inversions/(float)test->inversions;
	    else if(inversions == 0) fitness = 1;
	    else fitness = -inversions;
	    
	    return fitness; 
	    }
	    
	    float evaluateNode(int popIndex, int testSet){
	    
	    float nodeTotalFitness = 0;
	    
	    for(int testNum = 0; testNum < NUM_TESTS; testNum++){
	    
	    nodeTotalFitness += testNode(popIndex, testSet, testNum);
	    
	    }
	    
	    population[popIndex].oldFitness = population[popIndex].fitness;
	    
	    population[popIndex].fitness = nodeTotalFitness / NUM_TESTS;
	    
	    if(population[popIndex].fitness > 0.8) success = 1;
	    
	    return population[popIndex].fitness;
	    
	    }
	    
	    void updateProgLen(int* updateList){
	    
	    if (updateList == NULL){
	    
	    for(int nextUpdateNode = 0; nextUpdateNode < POPULATION_SIZE; nextUpdateNode++){
	    
	    Node* node = &population[nextUpdateNode];
	    
	    node->progLen = 1;
	    
	    for(int arg = 0; arg < primitiveTable[node->primitive].arity; arg++){
	    
	    node->progLen += population[node->operands[arg]].progLen;
	    
	    }
	    
	    
	    }
	    
	    
	    }
	    else{
	    for(int nextUpdateNode = updateList[0]; nextUpdateNode != 0; nextUpdateNode = updateList[nextUpdateNode]){
	    
	    Node* node = &population[nextUpdateNode];
	    
	    node->progLen = 1;
	    
	    for(int arg = 0; arg < primitiveTable[node->primitive].arity; arg++){
	    
	    node->progLen += population[node->operands[arg]].progLen;
	    
	    }
	    
	    
	    }
	    }
	    
	    }
	    
	    void normaliseFitness(){
	    
	    int prawTable[POPULATION_SIZE];
	    int raw[POPULATION_SIZE];
	    float adj[POPULATION_SIZE];
	    float adjSum = 0;
	    
	    prawTable[0] = population[0].fitness;
	    
	    int minpraw = prawTable[0];
	    
	    
	    for(int popIndex = 1; popIndex < POPULATION_SIZE; ++popIndex){
	    
	    prawTable[popIndex] = population[popIndex].fitness;
	    
	    if(prawTable[popIndex] < minpraw) minpraw = prawTable[popIndex];
	    
	    }
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; ++popIndex){
	    
	    int raw = prawTable[popIndex] - minpraw;
	    
	    adj[popIndex] = 1.0/(1.0+raw);
	    
	    adjSum += adj[popIndex];
	    
	    }
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; ++popIndex){
	    
	    population[popIndex].fitness = adj[popIndex]/adjSum;
	    
	    }
	    
	    }
	    
	    float evaluatePopulationSNGP_A(int* updateList, int testSet){
	    
	    if(updateList == NULL){
	    
	    totalNodeFitness = 0;
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; popIndex++){
	    
	    totalNodeFitness += evaluateNode(popIndex, testSet);
	    
	    }
	    } else{
	    
	    for(int nextUpdateNode = updateList[0]; nextUpdateNode != 0; nextUpdateNode = updateList[nextUpdateNode]){
	    
	    totalNodeFitness += evaluateNode(nextUpdateNode, testSet);
	    
	    totalNodeFitness -= population[nextUpdateNode].oldFitness;
	    
	    }
	    }
	    
	    return totalNodeFitness/POPULATION_SIZE;
	    
	    }
	    
	    float evaluatePopulationSNGP_B(int* updateList, int testSet){
	    
	    float bestNodeFitness = 0;
	    
	    if(updateList == NULL){
	    
	    bestNodeFitness = evaluateNode(0, testSet);
	    
	    for(int popIndex = 1; popIndex < POPULATION_SIZE; popIndex++){
	    
	    float nodeFitness = evaluateNode(popIndex, testSet);
	    if(bestNodeFitness BETTER_THAN nodeFitness) bestNodeFitness = nodeFitness;
	    
	    }
	    } else{
	    
	    for(int nextUpdateNode = updateList[0]; nextUpdateNode != 0; nextUpdateNode = updateList[nextUpdateNode]){
	    
	    evaluateNode(nextUpdateNode, testSet);
	    
	    }
	    
	    bestNodeFitness = population[0].fitness;
	    
	    for(int i = 1; i<POPULATION_SIZE; ++i){
	    
	    if(population[i].fitness BETTER_THAN bestNodeFitness) bestNodeFitness = population[i].fitness;
	    
	    }
	    }
	    
	    return bestNodeFitness;
	    }
	    
	    void successorMutate(int popIndex, int randomOperandIndex, int newOperandValue){
	    
	    Node* node = &population[popIndex];
	    
	    removePredecessor(node->operands[randomOperandIndex], popIndex);
	    
	    node->operands[randomOperandIndex] = newOperandValue;
	    
	    addPredecessor(newOperandValue, popIndex);
	    }
	    
	    int addToUpdateList(int popIndex){
	    
	    int nextValue = 0;
	    
	    while(updateList[nextValue] != 0 && updateList[nextValue] < popIndex){
	    
	    nextValue = updateList[nextValue];
	    
	    }
	    
	    if(updateList[nextValue] != popIndex){
	    
	    updateList[popIndex] = updateList[nextValue];
	    
	    updateList[nextValue] = popIndex;
	    
	    //popIndex is not already in update list
	    return 0;
	    
	    } else{
	    
	    //popIndex is already in update list
	    return 1;
	    
	    }
	    
	    
	    }
	    
	    //updateList[0] must be set to 0 before this function is called
	    void buildUpdateList(int popIndex){
	    
	    addToUpdateList(popIndex);
	    
	    int* predArray = population[popIndex].predecessors;
	    
	    int nextPredecessor = predArray[0];
	    
	    while(nextPredecessor != 0){
	    
	    int inList = addToUpdateList(nextPredecessor);
	    if(!inList) buildUpdateList(nextPredecessor);
	    nextPredecessor = predArray[nextPredecessor];
	    
	    }
	    
	    }
	    
	    void restoreFitnessValues(int* list){
	    
	    int nextNode = list[0];
	    
	    while(nextNode != 0 && nextNode < POPULATION_SIZE){
	    
	    population[nextNode].fitness = population[nextNode].oldFitness;
	    
	    nextNode = list[nextNode];
	    
	    }
	    
	    }
	    
	    int init(char* path){
	    if(path == NULL) return 1;
	    if(initialiseTestData(path)) return 1;
	    srand(RANDOM_SEED);
	    results = malloc( arrayMem(maxTestSize) );
	    mergeBuffer1 = malloc( sizeof(int) * maxTestSize );
	    mergeBuffer2 = malloc( sizeof(int) * maxTestSize );
	    return 0;
	    
	    }
	    
	    #include "SNGP_Sort_Debug.c"
	    
	    int main(int argc, char* argv[]){
	    
	    printf("Start\n\n");
	    printf(argv[1]);
	    printf("\n\n");
	    
	    printPrimitiveTable();
	    
	    if(init(argv[1])){
	    printf("File Not Found");
	    return 1;
	    }else{
	    
	    printf("\nTest file loaded\n\n");
	    
	    }
	    /*
	    initialisePopulation();
	    initialiseExamplePopulation();
	    updateProgLen(NULL);
	    evaluatePopulation(NULL,0);
	    printPopulation();*/
	    
	    fitnessTrace = fopen(OUT_FILE,"w");
	    
	    for(int run = 0; run<MAX_RUNS; ++run){
	    
	    if(success==1) break;
	    
	    printf("\n\nRun %d\n\n",run);
	    
	    initialisePopulation();
	    //initialisePartialSolution();
	    //updateProgLen(NULL);
	    float oldFitness = (1 BETTER_THAN 0)? INT_MAX: INT_MIN;
	    
	    //evaluate the initial population (generation 0)
	    float fitness = evaluatePopulation(NULL, 0);
	    
	    
	    for(int generation = 1; generation < NUM_GENERATIONS; ++generation){
	    
	    if(success==1) break;
	    
	    if(generation % OUTPUT_INTERVAL ==0)printf("\nGeneration %d",generation);
	    
	    int randomNodeIndex = randRange(NUM_TERMINALS, NUM_PRIMITIVES-1);
	    Node* randomNode = &population[randomNodeIndex];
	    int randomOperandIndex = randRange(0, primitiveTable[randomNode->primitive].arity-1);
	    int oldOperandValue = randomNode->operands[randomOperandIndex];
	    int randomOperandValue = randRange(0,randomNodeIndex-1);
	    
	    successorMutate(randomNodeIndex, randomOperandIndex, randomOperandValue);
	    
	    updateList[0] = 0;
	    
	    buildUpdateList(randomNodeIndex);
	    
	    updateProgLen(updateList);
	    
	    oldFitness = fitness;
	    
	    fitness = evaluatePopulation(updateList, generation % NUM_TEST_SETS);
	    
	    if(!(fitness BETTER_THAN oldFitness)){
	    
	    restoreFitnessValues(updateList);
	    
	    fitness = oldFitness;
	    
	    removePredecessor(randomOperandValue, randomNodeIndex);
	    
	    randomNode->operands[randomOperandIndex] = oldOperandValue;
	    
	    addPredecessor(oldOperandValue, randomNodeIndex);
	    
	    }      
	    
	    fprintf(fitnessTrace,"%f,",fitness);
	    if(generation % OUTPUT_INTERVAL ==0)printf(" Fitness: %f\n", fitness);
	    
	    }
	    
	    fprintf(fitnessTrace,"\n");
	    }
	    printPopulation();
	    
	    fclose(fitnessTrace);
	    
	    if(success == 1){
	    
	    printf("\n\nSuccess!\n\n");
	    
	    printNode(workingProgramme);
	    
	    }else{
	    
	    printf("\n\nNo working programme\n\n");
	    
	    }
	    
	    return 0;
	    }
	    \end{lstlisting}
	    
	    Code listing for SNGP\_Sort\_Debug.c
	    
	    \begin{lstlisting}
	    #ifndef SNGP_SORT_DEBUG_C
	    #define SNGP_SORT_DEBUG_C
	    
	    #include<stdio.h>
	    
	    void printIntArray(int* a, int n){
	    
	    for(int i = 0; i<n; i++){
	    
	    printf("%d ", a[i]);
	    
	    }
	    
	    }
	    
	    void printPrimitiveTable(){
	    
	    for(int i = 0; i < NUM_PRIMITIVES; i++){
	    
	    TableEntry entry = primitiveTable[i];
	    printf("i: %d, e: %d, a: %d n: %s\n", i, entry.primitive, entry.arity, entry.name);
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    void printTestData(){
	    
	    for(int i = 0; i < NUM_GENERATIONS; i++){
	    
	    printf("Set %d\n\n", i);
	    
	    for(int j = 0; j < NUM_TESTS; j++){
	    
	    Array* test = tests[i][j];
	    
	    printf("Test: %d-%d Size: %d Inversions: %d\n", i, j, test->size, test->inversions);
	    
	    for(int k = 0; k < test->size; k++){
	    
	    printf("%d " , test->arr[k]);
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    printf("\n");
	    
	    }
	    
	    void printNode(int popIndex){
	    
	    Node node = population[popIndex];
	    
	    printf(
	    "Index: %d primitive: %s Arity: %d\nFitness: %f OldFitness: %f ProgLen: %d\nOperands: ", 
	    popIndex,
	    primitiveTable[node.primitive].name,
	    primitiveTable[node.primitive].arity,
	    node.fitness,
	    node.oldFitness,
	    node.progLen
	    );
	    
	    for(int j = 0; j < primitiveTable[node.primitive].arity; j++ ){
	    printf("%d ",node.operands[j]);
	    }
	    
	    printf("\nPredecessors: ");
	    
	    /*for(int j = 0; j < POPULATION_SIZE; ++j){
	    
	    if(node.predecessors[j]!=0)printf("%d ",node.predecessors[j]);
	    
	    }*/
	    
	    for(int i = node.predecessors[0]; i != 0; i = node.predecessors[i]){
	    
	    
	    printf("%d ",i);
	    
	    }
	    
	    }
	    
	    void printPopulation(){
	    
	    
	    for(int popIndex = 0; popIndex < POPULATION_SIZE; popIndex++){
	    
	    printNode(popIndex);
	    
	    printf("\n\n");
	    }
	    
	    printf("\n");
	    
	    }
	    
	    void initialiseExamplePopulation(){
	    
	    population[0].primitive = INDEX;
	    
	    population[1].primitive = LENGTH;
	    
	    population[2].primitive = INC;
	    population[2].operands[0] = 0;
	    
	    population[3].primitive = SMALLEST;
	    population[3].operands[0] = 2;
	    population[3].operands[1] = 0;
	    
	    population[4].primitive = SWAP;
	    population[4].operands[0] = 3;
	    population[4].operands[1] = 0;
	    
	    population[5].primitive = SUB;
	    population[5].operands[0] = 1;
	    population[5].operands[1] = 1;
	    
	    population[6].primitive = DEC;
	    population[6].operands[0] = 1;
	    
	    population[7].primitive = ITERATE;
	    population[7].operands[0] = 5;
	    population[7].operands[1] = 6;
	    population[7].operands[2] = 4;
	    
	    population[8].primitive = ITERATE;
	    population[8].operands[0] = 5;
	    population[8].operands[1] = 6;
	    population[8].operands[2] = 7;
	    
	    population[9].primitive = SWAP;
	    population[9].operands[0] = 6;
	    population[9].operands[1] = 0;
	    
	    }
	    
	    void initialisePartialSolution(){
	    
	    population[12].primitive = INC;
	    population[12].operands[0] = 0;
	    
	    population[20].primitive = SMALLEST;
	    population[20].operands[0] = 2;
	    population[20].operands[1] = 0;
	    
	    population[25].primitive = SWAP;
	    population[25].operands[0] = 3;
	    population[25].operands[1] = 0;
	    
	    population[33].primitive = SUB;
	    population[33].operands[0] = 1;
	    population[33].operands[1] = 1;
	    
	    population[40].primitive = DEC;
	    population[40].operands[0] = 1;
	    
	    population[42].primitive = ITERATE;
	    population[42].operands[0] = 33;
	    population[42].operands[1] = 40;
	    population[42].operands[2] = 25;
	    
	    }
	    
	    void testExecution(){
	    
	    initialiseExamplePopulation();
	    printPopulation();
	    
	    results = malloc(arrayMem(maxTestSize));
	    
	    printf("Test data initialised\n");
	    
	    int testResult = testNode(8,2,1);
	    
	    for(int i = 0; i < results->size; i++){
	    
	    printf("%d ", results->arr[i]);
	    
	    }
	    
	    }
	    
	    #endif
	    \end{lstlisting}
	    
	    Code listing for testGenerator.py
	    
	    \begin{lstlisting}
	    from random import randint
	    from sys import argv
	    
	    #length20, inversions = 86
	    testArr1 = [82,160,286,169,65,275,35,376,288,87,398,57,66,80,41,195,154,314,375,167]
	    
	    #length = 17, inversions = 82
	    
	    testArr2 = [206, 344, 377, 270, 117, 14, 304, 125, 178, 134, 222, 187, 201, 257, 159, 41, 178]
	    
	    minIntVal = 0
	    maxIntVal = 400
	    
	    minArrSize = 2
	    maxArrSize = 30
	    
	    numTests = 30
	    maxOps = 30000
	    
	    def countInversions(arr):
	    
	    if len(arr) <= 1:
	    return 0
	    
	    mid = len(arr)//2
	    a = arr[:mid]
	    b = arr[mid:]
	    
	    inversions = countInversions(a) + countInversions(b)
	    
	    aCounter = 0
	    bCounter = 0
	    cCounter = 0
	    
	    while aCounter < len(a) and bCounter < len(b):
	    if a[aCounter] <= b[bCounter]:
	    arr[cCounter] = a[aCounter]
	    aCounter+=1
	    else:
	    arr[cCounter] = b[bCounter]
	    bCounter+=1
	    inversions+=(len(a)-aCounter)
	    
	    cCounter+=1
	    
	    if aCounter < len(a):
	    for i in range(aCounter, len(a)):
	    arr[cCounter] = a[i]
	    cCounter+=1
	    else:
	    for i in range(bCounter, len(b)):
	    arr[cCounter] = b[i]
	    cCounter+=1
	    
	    return inversions    
	    
	    def randArr():
	    arr = []
	    for i in range(randint(minArrSize,maxArrSize+1)):
	    arr.append(randint(minIntVal, maxIntVal+1))
	    return arr
	    
	    def main():
	    #print(countInversions(testArr2))
	    file = open(argv[1],"w+")
	    outString = ""
	    for testSet in range(maxOps):
	    for test in range(numTests):
	    arr = randArr()
	    outString += str(len(arr)) + " "+ str(countInversions(arr.copy())) + " " + str(arr).strip('[]').replace(",","") + "\n"
	    outString += "\n"
	    file.write(outString)
	    
	    if __name__ == "__main__":
	    main()
	    
	    \end{lstlisting}

\end{document}