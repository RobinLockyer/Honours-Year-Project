\documentclass{article}

\usepackage[affil-it]{authblk}
\usepackage{graphicx}
\usepackage{float}
\usepackage[ruled]{algorithm2e}
\usepackage{titlepic}

\graphicspath{{../resources/}}

\SetKwProg{function}{Function}{}{}
\newcommand{\assign}[2]{$#1 \leftarrow$ #2}

\title{COMP390 Evolving a Sorting Algorithm with SNGP}
\author{Robin Lockyer\\{\small Student ID: 201148882 \\ Primary Supervisor: Dr. David Jackson \\ Secondary Supervisor: Dr. Valentina Tamma}}
\date{2018/2019}
\titlepic{\includegraphics[width=0.5\textwidth]{UOL_Logo.png}}

\begin{document}
	
	\maketitle	
	
	\newpage
	
	\begin{abstract}
		
		Genetic programming is a technique for creating programmes not by writing them by hand, but instead by creating a population of random programmes and modifying them using an evolutionary algorithm. The desired result is that after several generations a programme that performs well at a given task is generated. GP has previously been used to successfully evolve sorting algorithms.
		
		Single node genetic programming is a variation on GP invented by Dr Jackson which structures the population of programmes in a manner that allows the use of dynamic programming when computing the result of the programmes in an effort to more efficiently generate a working solution. 
		
		This project aims to compare the effectiveness of the two methods in evolving a sorting algorithm.
		
	\end{abstract}
	\newpage
	\tableofcontents
	\newpage
	\section{Introduction}
	
		This project is was done for my project supervisor Dr David Jackson. The aim of this project is to attempt to evolve a sorting algorithm using node genetic programming (SNGP) and, if successful, compare the effectiveness of evolving sorting algorithms using standard genetic programming (GP) to evolving sorts with SNGP.
		
		The purpose of GP is to automate the creation of algorithms and programmes. This is done by applying a genetic algorithm to a population of random programmes so that successive generations of programmes improve at the desired characteristics until a functional programme is created.
		The standard approach to GP requires evaluating hundreds of programmes per generation over potentially thousands of generations and as such GP can take up a large amount of processing time. Several variations of GP have been created that try to reduce the amount of processing, including Linear Genetic Programming and Parallel Distributed GP \cite{poli_field_2008}.
		
		SNGP is one such variation devised by Dr Jackson in \textit{A New, Node-Focused Model for Genetic Programming} \cite{jackson_new_2012}. This variation makes use of a form of dynamic programming to re-use results of previously evaluated programmes. It has been shown that SNGP tends to perform better than standard GP in terms of processing time, solution rate, and solution size \cite{jackson_new_2012}. SNGP has reduced efficiency when dealing with problems with side-effects because this prevents re-use of evaluations, although it still performs better than GP at some problems with side effects \cite{jackson_single_2012}. 
		
		A sorting algorithm reads and manipulates an array of integers as it executes, and so must make use of side effects. Regular genetic programming has been shown to be capable of evolving a working sorting algorithm \cite{kinnear_evolving_1993,kinnear_generality_1993}. This makes evolving a sort a good problem to evaluate SNGP on as comparisons can be made with previous research.
	
	\section{Background}
	
		\subsection{Standard Genetic Programming}
			
			Genetic programming allows the user to automate finding solutions to problems without the need to know much about the solutions themselves. This is done by a stochastic process where successive generations of programmes are altered to create the next generation, with the goal of each generation being an improvement on the last until a desired result is found.
			
			In standard the standard form of GP, described in \textit{A Field Guide to Genetic programming} \cite{poli_field_2008}, programmes are encoded as a tree of primitive functions and terminals. Each function has a number of child nodes equal to it's arity, and each individual child represents a single operand of the parent function. Nodes with no children represent terminal functions or constants which require no input. Figure \ref{fig:ex_prog_tree} shows an example of a programme encoded as a tree.
			
			\begin{figure}
				\centering
				\includegraphics[width=0.5\textwidth]{1_gp_example_tree}
				\label{fig:ex_prog_tree}
				\caption{This tree encodes the programme f( g( a, b, c ), f( h( a ), a ) ), where f, g, and h are functions and a, b, and c are terminals.}
			\end{figure}
			
			An initial population of random programme trees is generated according to certain parameters that can vary depending on implementation. Each member of the population is executed in turn. The results of these executions are evaluated and each member of the population is given a fitness score so that better programmes have higher scores.
		
			Members of the population are then selected to produce offspring programs based on their fitness. Simply selecting the best individuals to reproduce can lead to low diversity in the resulting population, so a probabilistic is often used to prevent a single programme's offspring from dominating subsequent generations.
			Common methods for doing this include fitness proportionate selection, where the probability of selection is proportional to the fitness of the individual relative to the fitness of the whole population, and tournament selection, where a small subset of programmes are chosen with equal probability and the fittest of the subset is selected for reproduction.
			
			Genetic operators are then applied to the chosen programmes to create a new generation. The operator selected to create each member is chosen with a pre selected probability. The three most commonly used operators, which are also the three operators Koza used to successfully evolve a sort \cite{kinnear_evolving_1993}, are:
			
			\begin{itemize}
				\item \textbf{Reproduction:} 
				
				\begin{figure}[h]
					\centering
					\includegraphics[width=0.3\textwidth]{5_reproduction}
					\label{fig:reproduction}
					\caption{Example of reproduction operator}
				\end{figure}
				
				The selected programme is copied into the new generation without modification. Reproduction tends to have a low selection probability to ensure the following generation si sufficiently different.
				
				\item \textbf{Crossover:} 
				
				\begin{figure}[h]
					\centering
					\includegraphics[height=0.2\textwidth]{6_crossover}
					\label{fig:crossover}
					\caption{Example of crossover operation. The highlighted nodes are the crossover points}
				\end{figure}
				
				A random node is selected as the crossover point in each of the two chosen programmes and the subtrees rooted at the selected nodes are swapped.

				
				\item \textbf{Mutation:} 
				
				\begin{figure}[h]
					\centering
					\includegraphics[width=0.4\textwidth]{7_mutation}
					\label{fig:mutation}
					\caption{Example of mutation operator. The highlighted node is replaced by the highlighted subtree.}
				\end{figure}
				
				A random node is selected in the chosen programme. A new, random subtree is generated to replace the subtree rooted at the selected node.
			\end{itemize}
			
			The process of creating new generation is continued until a certain condition is reached, usually after a certain number of generations or a programme exceeds a fitness specified by the user.
			
		\subsection{Single Node Genetic Programming}
		
			Single Node Genetic Programming is a variant of GP that uses a form of dynamic programming to speed up the evaluation of GP programmes.
			
			The population is organised a single directed acyclic graph. This allows the nodes to be organised into topological ordering such that any given node only uses nodes later in the ordering as operands. The nodes are stored in an array in this order, with all the terminals occupying the lowest values, as shown in \ref{fig:sngp_graph}
			
			\begin{figure}
				\centering
				\includegraphics[width=0.5\textwidth]{8_sngp_graph}
				\label{fig:sngp_graph}
				\caption{This SNGP graph is stored in topological order in an array. Terminals a,b, and c occupy the lowest positions of the array.}
			\end{figure}
		 
		\subsection{Prior Work on Evolving a Sort}
	
	\section{Data Required}
	
	\section{Design}
	
		\subsection{GP Implementation}
		
		The GP implementation was based example code given by Dr Jackson and also on an implementation of the TinyGP system found in the book \textit{A Field Guide to Genetic
		Programming} \cite{poli_field_2008}. It was written in C as the example code given to me was also in C. The exact parameters are the same as described in Koza's work \cite{kinnear_generality_1993}.
		
		Each programme is stored as a string of primitive functions and terminals. The string is in prefix notation, and as all primitives have fixed arity no bracketing is needed. Executing a programme is done by a recursive interpreter 
		
		The each member of the population is initialised by using the grow method. A maximum tree depth is specified and a random primitive is selected as the root. Random primitives are selected as the children for primitives that have been previously selected. The primitives can be either functions or terminals, unless selecting a function would cause the tree to exceed the maximum depth. The initial maximum depth is chosen to be 6 to match Koza's work. The pseudocode for the algorithm is shown in
		
		\begin{algorithm}
			\KwIn{maxTreeDepth}
		\end{algorithm}
	
		Three genetic operators are used: crossover, reproduction, and mutation. 
		
		\begin{algorithm}[H]
			
			$initialisePopulation()$
			
			$evaluatePopulation(0)$
			
			\For{$generation \leftarrow 1$ \KwTo $NUM\_GENERATIONS$}{
				
				\For{$j \leftarrow$  \KwTo $POPULATION\_SIZE$}{
					
					\uIf{$randInt(1,10) <= 8$}{
					
						$newPopulation[j] \leftarrow crossover(selectProg(),selectProg())$
						
					}
					\Else{$newPopulation[j] \leftarrow reproduce(selectProg())$ }
					
				}
			
				\ForEach{$programme \in newPopulation$}{
					
					\If{$randInt(1,10) = 1$}{
						
						$mutate(programme)$
						
					}
			
				}
			
				$population \leftarrow newPopulation$
			
				$evaluatePopulation(generation)$
		
			}
		
			\KwOut{$best(population)$}
				
			\caption{Genetic Programming Algorithm}
			
			\label{alg:GP}
		\end{algorithm}
		
		\subsection{SNGP Implementation}
		
		\subsection{Fitness Functions}
		
			While many different fitness functions were used, they all counted the number of inversions in a test array before and after executing a programme. To efficiently count inversions I used a modified merge sort algorithms, detailed in algorithm \ref{alg:countInv}. The algorithm is $O(n\log{}n)$, and merging is done using two preallocated buffers to avoid unnecessary memory allocations while the GP algorithm is running.
			
			\begin{algorithm}
				
				\SetKw{countInversions}{countInversions}
				
				\function{\countInversions{$(arr)$}:}{
				
					\uIf{$length(arr) <= 1$}{
						
						\assign{inversions}{$0$}
				
					}
				
					\Else{
					
						\assign{sizeA}{$\left\lfloor length(arr) / 2 \right\rfloor$}
						
						\assign{sizeB}{length(arr) - sizeA}
						
						\assign{A}{[First sizeA elements of arr]}
						
						\assign{B}{[Last sizeB elements of arr]}
						
						\assign{inversions}{countInversions(A) + countInversions(B)}
						
						\assign{C}{Empty Array}
						
						\While{$length(A) > 0 and length(B) > 0$}{
						
							\uIf{$B[1] < A[1]$}{
								
								Append B[1] to C
								
								\assign{inversions}{inversions + length(A)}
								
								Remove first element of B
						
							}
							\Else{
							
								Append A[1] to C
								
								Remove first element of A
							
							}
						}
						
						\uIf{$length(A) = 0$}{
						
							Append remaining elements of B to C
						
						}
						\ElseIf{$length(B) = 0$}{
							Append remaining elements of A to C
						}
					
						\assign{arr}{C}
				
					}
				
					\KwOut{inversions}
			
				}
				
				\caption{Algorithm that sorts array and counts number of inversions}
				
				\
				
				\label{alg:countInv}
				
			\end{algorithm}
		
		\subsection{Test Data}
		
			Each programme generated during a GP run is executed on a set of test arrays. This data comes from pre-generated file containing a series of random arrays loaded into the programme at the beginning of execution. This has the advantage of allowing for reproduction of results, easier testing of the programme, and prevents random number generation from increasing the execution time.
			
			The arrays are organised into fixed size groupings. Each programme in the same GP generation is executed on the same group of arrays. This was done so that each programme was subjected to the same conditions in each generation, while still preventing over fitting to a fixed set of data. This method also allows each group to be customized to meet certain requirements (e.g. contains a sorted array, a reversed array, or a very short array), but this was found to be unnecessary.
			
			The file is a standard text file where the first two values on each line are the length and number of inversions of the array, followed by the array itself. Each value is separated by a space. A blank line indicates the end of the current group of arrays.
	
	\section{Realisation}
	
	\section{Results}
	
	
	
	\section{Evaluation}
	
	\section{Learning Points}
	
	\section{Professional Issues}
	
	\section{Bibliography}
	
		\bibliographystyle{acm}
		\bibliography{library}
	
	\section{Appendices}
		
\end{document}